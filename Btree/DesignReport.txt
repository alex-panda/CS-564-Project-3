4. Design report: 15%. Your design report must describe the following design choices that you make:
    • Any implementation choices that you make. How often do you keep pages
        pinned? How efficient is your implementation? We are not going to run a
        speed test, but will look at the code to check if you are performing operations
        that are inefficient, such as unnecessarily traversing the tree up and down mul-
        tiple times during range searches
    • Please use your report to justify any additional design choices that you make.




For this project, we implemented a B+ tree index on a search key that is of type integer. 
A B+ tree index is widely used in many database management systems because it supports very 
efficient equality and range search. For this assignment, the index stores data entries in 
the form of key and record id pairs.

With regards to our implementation, we build the index by repeatedly calling the 
insertEntry method for each record in the relation. If the tree only contains
the root node, we insert the data entry into the root. If the tree contains more than 
just the root node, we perform binary search to find the appropriate leaf node and insert 
the record accordingly. If the leaf node is full, we split it into two nodes, redistribute 
the keys evenly, and copy the middle key up to the parent node. If the parent node isn’t 
full, then we just copy the key into the node. If the parent node is full, we redistribute 
the keys evenly, and push the middle key up the tree. This can propagate recursively to 
other nodes. The maximum number of pages that are pinned is equal to the height of the tree. 
All pages eventually get unpinned by the time the insertEntry method returns. 

Created Tests:
 - test4
    - Tests whether the bTree can handle negative values.
 - test5
    - Tests whether the bTree can handle an empty Tree
